---
title: 【Rails初学者】バリデーションの基礎についてざっくり理解する -Part1（概要編）
tags:
  - Rails
  - バリデーション
  - 初学者
private: false
updated_at: '2025-12-13T22:28:13+09:00'
id: 2e9d1bccf1ff9e8ab9e1
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに
Railsのバリデーションには元から多くの種類が用意されておりエンジニアはそれらを活用して効率的に開発を進めることができますが、種類が多く頭の中で整理しきれていないと感じています。
今回はバリデーションについて基礎からまとめていき、自分の整理用としてまとめていきたいと思います🧑‍💻

![validation.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3117662/bf2e1003-55bf-43f9-bd1f-2d77378d0b49.png)

# バリデーションとは
データベースに保存する前に、データが正しいかどうかをチェックする仕組みです！
例えば、ユーザー登録の際にメールアドレスが正しい形式であるか、パスワードが一定の長さを満たしているかなどを確認します。

![validation-flow.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3117662/7e5a7bca-801e-416e-9611-92ce82b5a075.png)

## バリデーションを行う理由
有効なデータのみをデータベースへ保存し、無効なデータが保存されるのを防ぐためです。
バリデーションによって、データの整合性と品質を保つための「門番」の役割を果たします！
少し強引ですが人間に例えると、「食べ物に毒が入っていないか？」「そもそも食べられるものなのか？」確認作業を行うイメージ🔍

#### モデルレベル以外でのバリデーション
Railsで開発する際には、モデルレベルでバリデーションを行うことがベストプラクティスとされていますが、他にも以下のようなレベルでバリデーションを行うことも方法としてあります。
下記のようなメリットデメリットがありますが、デメリットの部分が大きいため、基本的にはモデルレベルでのバリデーションが推奨⚠️

| レベル               | メリット・利用場面       | デメリット         |
|----------------------|----------------|--------------------|
| データベース | ・Rails以外からもDBを参照する場合<br>・モデルレベルのバリデーションの補完 | ・テストや保守の難易度が高い |
| クライアントサイド | ・ユーザー体験の向上（即時フィードバック） | ・セキュリティリスク（容易に回避可能） |
| コントローラーレベル | (基本的には推奨されない) | ・コードの重複や複雑化<br>・テストと保守の難易度が高い |

## バリデーションが実行されるタイミング
バリデーションは、「**オブジェクトの状態をデータベースに保存（永続化）しようとした直前**」に実行されます！
具体的には、SQL（`INSERT`や`UPDATE`）が実行される直前にバリデーションが行われ、もしバリデーションに失敗するとSQLは発行されず、保存処理がロールバックされます。

### バリデーションが実行されるメソッド
| メソッド名        | 説明                                   | 失敗時の挙動 |
|------------------|----------------------|----------------|
| `save`           | オブジェクトを保存 |   保存されず`false`を返す |
| `save!`          | 同上 | ActiveRecord::RecordInvalid 例外が発生し、処理が止まる|
| `create` | オブジェクトの作成と保存(save)を一度に行う | そのオブジェクトを返すだけ |
| `create!`          | 同上 | ActiveRecord::RecordInvalid 例外が発生し、処理が止まる|
| `update`         | 既存のオブジェクトを更新 | 保存されず`false`を返す |
| `update!`         | 同上 | ActiveRecord::RecordInvalid 例外が発生し、処理が止まる |

また、SQL（`INSERT`や`UPDATE`）の実行は必要ないが、バリデーションだけを実行したい場合には、以下のメソッドを使用できます。
| メソッド名        | 説明                 | 返り値 |
|------------------|----------------------|----------------|
| `valid?`         | オブジェクトが<font color=red>有効か</font>どうかをチェック | 有効のときは`true`、無効のときは`false` |
| `invalid?`       | オブジェクトが<font color=blue>無効か</font>どうかをチェック | 無効のときは`true`、有効のときは`false` |

### バリデーションがスキップされるメソッド
先ほど、「**オブジェクトの状態をデータベースに保存（永続化）しようとした直前**」にバリデーションが実行されると説明しましたが以下のメソッドでは、バリデーションがスキップされるため使用する際には注意が必要です😮

| メソッド名 | 説明 |
|-----------|------|
| `insert` | 単一レコードを直接挿入 |
| `insert!` | 単一レコードを直接挿入（失敗時に例外） |
| `insert_all` | 複数レコードを一括挿入 |
| `insert_all!` | 複数レコードを一括挿入（失敗時に例外） |
| `toggle!` | 真偽値属性を反転させて即座に保存 |
| `touch` | `updated_at`/`updated_on`を現在時刻に更新 |
| `touch_all` | 複数レコードの`updated_at`を一括更新 |
| `update_all` | 複数レコードを条件指定で一括更新 |
| `upsert` | レコードが存在すれば更新、なければ挿入 |
| `upsert_all` | 複数レコードをupsert処理 |
| `save(validate: false)` | バリデーションを明示的にスキップして保存 |

<sub>参考：[Railsガイド バリデーションのスキップ](https://railsguides.jp/active_record_validations.html#%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%82%B9%E3%82%AD%E3%83%83%E3%83%97)より</sub>

他にもスキップするメソッドがありますので、詳細はRailsガイドをご参照ください。

## バリデーションでエラーが発生したとき
バリデーションでエラーが発生したとき、そのエラー内容は`errors`オブジェクトに格納されます。
この`errors`オブジェクトを利用することで、どの属性でどのようなエラーが発生したのかを確認することができます。

```ruby
# Userモデル
class User < ApplicationRecord
  validates :name, presence: true
end
```

```ruby
# Railsコンソール
user = User.new(name: "")
user.valid?  # => false

user.errors[:name]
# => ["を入力してください"]
```

`errors`オブジェクトが持つ便利なメソッドがいくつかあるのですが、長くなりそうなので、また別の記事でまとめたいと思います💪

:::note info
`errors`オブジェクトとは？
- `ActiveModel::Errors`クラスのインスタンスで、モデルオブジェクトに関連するバリデーションエラー情報を格納・管理するためのオブジェクト
- ActiveRecordインスタンスの`errors`メソッドを通じてアクセス可能
- `Enumerable`モジュールをインクルードしているため、反復処理が可能
:::


# 参考記事
https://railsguides.jp/active_record_validations.html

